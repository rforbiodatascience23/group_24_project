---
title: "clean_mouse"
format: html
editor: visual
---

## Quarto

This document cleanes the mouse data

```{r}
library(dplyr)
library(tidyr)
library(tidyverse)
```

```{r}
mouse_data <- read_tsv(file = "../data/01_dat_load_mouse.tsv.gz")
```

```{r}
# Convert to long format
mouse_data_long <- mouse_data %>%
  pivot_longer(
    cols = -c(gene_id, symbol), # Exclude gene_id and symbol
    names_to = "treatment_replicate",
    values_to = "expression_levels"
  )

# Separate the treatment and replicate information
mouse_data_separated <- mouse_data_long %>%
  separate(
    col = treatment_replicate,
    into = c("treatment", "replicate"),
    sep = "-"
  )

# View the result
head(mouse_data_separated)

```

```{r}
#Old code, but I (Oliver) commented it out, to work with relative expression levels, so this is not needed here anymore

# Log2 transform the code, but first add a very samll number to all values, in order to avoid log(0). 
# The number we add is 99% fo the minimum value, so that we can still differentiate the artificial low values with the actual min, if needed.
min_non_zero_value <- min(mouse_data_separated$expression_levels[mouse_data_separated$expression_levels > 0])
#
mouse_data_separated <- mouse_data_separated |>
  mutate(expression_levels = ifelse(expression_levels == 0,
                                    0.65 * min_non_zero_value,
                                    expression_levels))

```

```{r}
#mouse_data_combined <- mouse_data_separated %>%
#  mutate(gene_id_symbol = paste(gene_id, symbol, sep = "_")) |>
#  select(-gene_id, -symbol)
mouse_data_combined <- mouse_data_separated |>
  select(-symbol)

```

```{r}
mouse_wide <- mouse_data_combined |> 
  pivot_wider(names_from = gene_id, values_from = expression_levels)
#drop row_id row
mouse_wide <- mouse_wide[-13,]

```

```{r}
write_tsv(x = mouse_wide, file = str_c("../data/02_dat_clean_mouse", ".tsv.gz"))
```

```{r}
#this is very costly to do on the entire dataframe
#test <- mouse_wide[3:10]
#test <- mouse_wide[3:]
zeroes_removed <- test %>% select_if(~ !all(. == 0))

# Replace zeroes with 65% of the minimum non-zero value in each row
zeroes_replaced <- zeroes_removed %>% 
  rowwise() %>% 
  mutate(across(everything(), ~ ifelse(. == 0, 0.65 * min(c_across(where(is.numeric))[c_across(where(is.numeric)) != 0], na.rm = TRUE), .)))

```

```{}
```

```{r}
df <- zeroes_replaced
# Function to calculate pairwise log-ratios
pairwise_log_ratios <- function(row) {
  combn(row, 2, function(pair) log(pair[1] / pair[2]))
}

# Calculate pairwise log-ratios for each row
log_ratios_list <- apply(df, 1, pairwise_log_ratios)

# Calculate variance for each pair of columns
num_cols <- ncol(df)
var_matrix <- matrix(NA, ncol = num_cols, nrow = num_cols)
combinations <- combn(num_cols, 2)

for (k in 1:ncol(combinations)) {
  # Extracting each combination
  i <- combinations[1, k]
  j <- combinations[2, k]

  # Extracting all log-ratios for the particular combination of columns
  log_ratios <- sapply(log_ratios_list, function(x) x[k])

  # Calculating variance for this pair of columns
  var_matrix[i, j] <- var(log_ratios, na.rm = TRUE)
  var_matrix[j, i] <- var_matrix[i, j]  # Mirror the variance as the matrix is symmetric
}

# Convert the matrix to a dataframe
var_df <- as.data.frame(var_matrix)
colnames(var_df) <- colnames(df)
rownames(var_df) <- colnames(df)

# Calculate total variation
totvar <- 1 / (2 * num_cols) * sum(var_matrix, na.rm = TRUE)

# Perturb and Scale DataFrame
gm <- apply(df, 1, function(row) exp(mean(log(row), na.rm = TRUE)))
df_perturbed <- sweep(df, 1, gm, "/")
df_scaled <- df_perturbed ^ (1 / totvar)
```
